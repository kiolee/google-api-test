<!doctype html>
<html><head>
<meta charset="utf-8">
<title>google API</title>
<link rel="stylesheet" href="css/responsive-nav.css">
<script src="js/responsive-nav.js"></script>
<script src="js/knockout-3.4.2.js"></script>
<script src="js/underscore-min.js"></script>

<style type="text/css">
     html, body { height: 100%; margin: 0; padding: 0; }
	 body{background:#666666;}
	 a{color:#ffffff;}
     #map { height: 100%; }
	 .nav-collapse{float:left;}
	 ul{}
	 li{ padding:10px; font-size:14px;}
	 a{cursor:pointer;}
	 input[type='text']{font-size:14px; line-height:20px;}
	 .check{color:#FF0004;}
   </style>
</head>


<body>
<nav class="nav-collapse">
	  

  <ul>
  <li><input type="text" name="filter" id="filter" data-bind="textInput:filterText,  event: { input: filter}" placeholder="输入地点名称筛选地理位置"></li>
  <!-- ko foreach: oPlaces -->
    <li><a data-bind="click:$parent.selectMarker, text: $data"></a></li>
	<!-- /ko -->
  </ul>
</nav>

<div id="map"></div>

<script type="text/javascript">

//保存6个地点名称
const myPlaces=['广州海军华海大厦', '富力天域中心','富力海珠城广场', '晓港公园', '明记海鲜城', '中山大学'];


var nav = responsiveNav(".nav-collapse");
// Create a map variable

var map;					//全屏地图
var addressResults=[];		//地理位置数组
var markers=[];				//标记数组
var infowindows=[];			//信息框数组
var filterTimeout;			//计时器，输入后执行筛选地点
//infowindows.push('yy');

// Function to initialize the map within the map div
	 
	 //获取地理位置，异步，返回promise，根据status执行reject或resolve
	 function getGeocode(address){
		let geocoder = new google.maps.Geocoder();
		return new Promise(function(resolve, reject){
			geocoder.geocode({'address': address}, function(results, status){
				//map.setCenter(results[0].geometry.location);
				//console.log(results);
				if (status !== google.maps.GeocoderStatus.OK) {
					return reject('cannot find address :'+address);
				}
				addressResults.push(results[0]);
				let marker = new google.maps.Marker({
					map: map,
					position: results[0].geometry.location,
					animation:google.maps.Animation.DROP
				});
				markers.push(marker);
				let infowindow=new google.maps.InfoWindow({
				   content: results[0].formatted_address,
				 });
				infowindows.push(infowindow);
				let length=markers.length;
				marker.addListener('click', function(){
					openInfoWindow(length-1);
				});
				console.log(address);
				resolve(address);
			});
			
		});
	 }
	 
	 
	//根据键值和显示参数使标记显示或隐藏的方法
	function markerDisplay(index, show){
		//console.log(index);
		if(show){
			markers[index].setMap(map);
		}
		else{
			markers[index].setMap(null);
		}
	}
	
	
	//信息框数组对应键值显示信息框方法
	function openInfoWindow(index){
		//console.log(index);
		for(let window of infowindows){
			window.close();
		}
		//console.log(index);
		let infowindow=infowindows[index];
		let marker=markers[index];
		let location=addressResults[index].geometry.location;
		infowindow.open(map, marker);
		map.panTo(location);
	}
	
	//根据输入文字筛选地点方法，输入后无动作1秒执行
	function filter(text){
		clearTimeout(filterTimeout);
		filterTimeout=setTimeout(function(){
			let regexp=new RegExp("[" + text + "]","i");
			_.map(text);
			console.log(text);
			}, 1000);
		//console.log(text);
	}
	 
	 
	 //初始化地图
     function initMap() {
		 map = new google.maps.Map(document.getElementById('map'), {
         zoom: 14
       });
	 
	 //获取全部地理位置，每个位置异步执行且按顺序排列
	 var loadPlaces=new Promise(function(resolve){
		let sequence=Promise.resolve();
		for(let place of myPlaces){
			sequence.then(function(res){
				getGeocode(place)
				.then(function(res){
					console.log('then call multi');		//这里执行N次
					resolve('why resolve call once');	//为什么resolve只执行1次
				}).catch(function(res){alert(res)})
				.then(function(resolve){
					console.log('why call multi and call after following code: loadPlaces.then?');	//这个then为什么执行在下面的then之后
				});		
			});
		}
	 });
	   
	   //获取完全部位置后设置地图中心为第一个位置坐标
	   loadPlaces.then(function(res){
		   console.log(res);
		   	console.log('why call before above code');
			map.setCenter(addressResults[0].geometry.location);
	   });
	   
	   /*
	   promise部分的结果看不明白，具体请看上面注释和console.log的结果
	   */
	   
     }
	 
	 
//knockout 绑定初始化

function koInit(){
	var self = this;
	self.filterText='';						//筛选框文字
	self.oPlaces = ko.observableArray();	//地点名称数组，克隆自myPlaces
	for(let place of myPlaces){
		self.oPlaces.push(place);
	}
	
	
	
	
	//左侧列表点击事件，显示信息框
	self.selectMarker=function(item){
		console.log(item);
		let index=_.indexOf(myPlaces, item);
		if(index>-1){
			openInfoWindow(index);
		}
	}
	
	//重置文字格式数组
	self.resetPlaces=function(){
		self.oPlaces.removeAll();
		//let i=0;
		for(let place of myPlaces){
			self.oPlaces.push(place);
			//markerDisplay(i, true);
			//i++;
		}
	}
	
	//筛选方法
	self.filter=function(){
		let that=self;
		clearTimeout(filterTimeout);
		let places=self.oPlaces();
		let filterText=self.filterText;
		//console.log(self.oPlaces);
		//输入框空侧重置地图和列表
		if(!self.filterText.length){
			console.log('clear');
			self.resetPlaces();
			for(let i=0; i<self.oPlaces().length; i++){
				markerDisplay(i, true);
			}
		}
		else{
			//执行定时器筛选位置
			filterTimeout=setTimeout(function(){
				let regexp=new RegExp(filterText,"gim");
				let removePlaces=_.filter(myPlaces, function(place){return ! regexp.test(place);});	//不符合条件的地点名称数组
				console.log(removePlaces);
				//先显示全部地点
				for(let i=0; i<myPlaces.length; i++){
					markerDisplay(i, map);
				}
				//再隐藏不符合条件的地点
				for(let place of removePlaces){
					let index=_.indexOf(myPlaces, place);
					markerDisplay(index, false);
				}
				//先重置地点名称数组，再删不符合条件的地点名称
				that.resetPlaces();
				that.oPlaces.remove(function(place){return ! regexp.test(place);});
			}, 1000);
		}
	}
	return self;
}

ko.applyBindings(new koInit());

	 
   </script>
   
<script async defer
     src="https://maps.googleapis.com/maps/api/js?v=3&key=AIzaSyC4YH8bmW5RvyCTUZKZgHDzRz_p3D6ZB5g&callback=initMap">
   </script>
   
</body>
</html>
